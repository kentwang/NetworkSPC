T003=trace(Ec^3)/6;
traceEc^3
Ec^3
T003=trace(Ec^3)/6;
trace(Ec^3)
class(Ec^3)
trace(Ec)
?trace
T003=tr(Ec^3)/6;
sum(diag(A))
A
tr = function(A) {
# calculate trace of a square matrix
return(sum(diag(A)))
}
T003=tr(Ec^3)/6;
T003
Ec^3
tr(Ec^3)
diag(Ec)
Ec^3
power(Ec, 3)
Ec*Ec*Ec
Ec %*% Ec
T003=tr(Ec %*% Ec %*% Ec)/6;
T003
T012=sum(sum(Ec %*% Ec2.*(C+C')))/2;
'
T012=sum(sum(Ec %*% Ec2.*(C + t(C))))/2;
T012=sum(sum(Ec %*% Ec2 * (C + t(C))))/2;
T012=sum(sum(Ec %*% Ec.*(C + t(C))))/2;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T012
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) * C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec- C * t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec-t(C) * C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=trace(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) * C * M))/2;
T120U=sum(sum(C * t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=trace(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) * C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec- C * t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec-t(C) * C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) * C * M))/2;
T120U=sum(sum(C * t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=trace(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) * C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec- C * t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec-t(C) * C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) * C * M))/2;
T120U=sum(sum(C * t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
T
sum(sum(t(C) * C * Ec))/2
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
T
choose(3, 2)
tr = function(A) {
# calculate trace of a square matrix
return(sum(diag(A)))
}
triadcensus = function(A){
#
# This function computes the triad census as given in Holland and Leinart's
# original paper.  Both directed and undirected networks are allowed.
# 
# Inputs: adjacency matrix A
# Outputs: Triad census proportions T
#
n = dim(A)[1]
E = matrix(0, n, n)
M = matrix(0, n, n)
for(i in 1:n) {
for(j in 1:n) {
if(A[i, j] == 1 | A[j, i] == 1) {
cat("E", i, j, "\n")
E[i, j] = 1
E[j, i] = 1
}
if(A[i, j] == 1 && A[j, i] == 1) {
cat("M", i, j, "\n")
M[i, j] = 1
M[j, i] = 1
}
}
}
# Define the following for use in counting configurations
C=A-M 
Ec=matrix(1, n, n) - diag(n) - E
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
return(T/choose(dim(A)[1], 3))
}
triadcensus = function(A){
#
# This function computes the triad census as given in Holland and Leinart's
# original paper.  Both directed and undirected networks are allowed.
# 
# Inputs: adjacency matrix A
# Outputs: Triad census proportions T
#
n = dim(A)[1]
E = matrix(0, n, n)
M = matrix(0, n, n)
for(i in 1:n) {
for(j in 1:n) {
if(A[i, j] == 1 | A[j, i] == 1) {
cat("E", i, j, "\n")
E[i, j] = 1
E[j, i] = 1
}
if(A[i, j] == 1 && A[j, i] == 1) {
cat("M", i, j, "\n")
M[i, j] = 1
M[j, i] = 1
}
}
}
# Define the following for use in counting configurations
C=A-M 
Ec=matrix(1, n, n) - diag(n) - E
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
return(T/choose(dim(A)[1], 3))
}
tr = function(A) {
# calculate trace of a square matrix
return(sum(diag(A)))
}
triadcensus = function(A){
#
# This function computes the triad census as given in Holland and Leinart's
# original paper.  Both directed and undirected networks are allowed.
# 
# Inputs: adjacency matrix A
# Outputs: Triad census proportions T
#
n = dim(A)[1]
E = matrix(0, n, n)
M = matrix(0, n, n)
for(i in 1:n) {
for(j in 1:n) {
if(A[i, j] == 1 | A[j, i] == 1) {
cat("E", i, j, "\n")
E[i, j] = 1
E[j, i] = 1
}
if(A[i, j] == 1 && A[j, i] == 1) {
cat("M", i, j, "\n")
M[i, j] = 1
M[j, i] = 1
}
}
}
# Define the following for use in counting configurations
C=A-M 
Ec=matrix(1, n, n) - diag(n) - E
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
return(T/choose(dim(A)[1], 3))
}
A
n = dim(A)[1]
E = matrix(0, n, n)
M = matrix(0, n, n)
for(i in 1:n) {
for(j in 1:n) {
if(A[i, j] == 1 | A[j, i] == 1) {
cat("E", i, j, "\n")
E[i, j] = 1
E[j, i] = 1
}
if(A[i, j] == 1 && A[j, i] == 1) {
cat("M", i, j, "\n")
M[i, j] = 1
M[j, i] = 1
}
}
}
# Define the following for use in counting configurations
C=A-M 
Ec=matrix(1, n, n) - diag(n) - E
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
return(T/choose(dim(A)[1], 3))
tr = function(A) {
# calculate trace of a square matrix
return(sum(diag(A)))
}
triadcensus = function(A){
#
# This function computes the triad census as given in Holland and Leinart's
# original paper.  Both directed and undirected networks are allowed.
# 
# Inputs: adjacency matrix A
# Outputs: Triad census proportions T
#
n = dim(A)[1]
E = matrix(0, n, n)
M = matrix(0, n, n)
for(i in 1:n) {
for(j in 1:n) {
if(A[i, j] == 1 | A[j, i] == 1) {
cat("E", i, j, "\n")
E[i, j] = 1
E[j, i] = 1
}
if(A[i, j] == 1 && A[j, i] == 1) {
cat("M", i, j, "\n")
M[i, j] = 1
M[j, i] = 1
}
}
}
# Define the following for use in counting configurations
C=A-M 
Ec=matrix(1, n, n) - diag(n) - E
% Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
T = T/choose(dim(A)[1], 3)
return(T)
}
tr = function(A) {
# calculate trace of a square matrix
return(sum(diag(A)))
}
triadcensus = function(A){
#
# This function computes the triad census as given in Holland and Leinart's
# original paper.  Both directed and undirected networks are allowed.
# 
# Inputs: adjacency matrix A
# Outputs: Triad census proportions T
#
n = dim(A)[1]
E = matrix(0, n, n)
M = matrix(0, n, n)
for(i in 1:n) {
for(j in 1:n) {
if(A[i, j] == 1 | A[j, i] == 1) {
cat("E", i, j, "\n")
E[i, j] = 1
E[j, i] = 1
}
if(A[i, j] == 1 && A[j, i] == 1) {
cat("M", i, j, "\n")
M[i, j] = 1
M[j, i] = 1
}
}
}
# Define the following for use in counting configurations
C=A-M 
Ec=matrix(1, n, n) - diag(n) - E
# Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
T = T/choose(dim(A)[1], 3)
return(T)
}
triadcensus(A)
tr = function(A) {
# calculate trace of a square matrix
return(sum(diag(A)))
}
triadcensus = function(A){
#
# This function computes the triad census as given in Holland and Leinart's
# original paper.  Both directed and undirected networks are allowed.
# 
# Inputs: adjacency matrix A
# Outputs: Triad census proportions T
#
n = dim(A)[1]
E = matrix(0, n, n)
M = matrix(0, n, n)
for(i in 1:n) {
for(j in 1:n) {
if(A[i, j] == 1 | A[j, i] == 1) {
E[i, j] = 1
E[j, i] = 1
}
if(A[i, j] == 1 && A[j, i] == 1) {
M[i, j] = 1
M[j, i] = 1
}
}
}
# Define the following for use in counting configurations
C=A-M 
Ec=matrix(1, n, n) - diag(n) - E
# Counts of 16 configurations in the triad census
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
T=c(T003, T012, T102, T021D, T021U, T021C, T111D, T111U, T030T, T030C, T201, T120D, T120U, T120C, T210, T300)
T = T/choose(dim(A)[1], 3)
return(T)
}
triadcensus(A)
triadcensus(adj[[2]])
triadcensus(adj[[3]])
T = matrix(0, length(adj), 16)
T = matrix(0, length(adj), 16)
for(i in 1:length(adj)) {
T[i, ] = triadcensus(adj[[i]])
}
T = matrix(0, length(adj), 16)
for(i in 1:length(adj)) {
cat("iter", i, "\n")
T[i, ] = triadcensus(adj[[i]])
}
test = lapply(adj, FUN = triadcensus)
ptm <- proc.time()
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
proc.time() - ptm
ptm <- proc.time()
for(k in 1:100){
T003=tr(Ec %*% Ec %*% Ec)/6;
T012=sum(sum(Ec %*% Ec * (C + t(C))))/2;
T102=sum(sum(Ec %*% Ec * M))/2;
T021D=sum(sum(t(C) %*% C * Ec))/2;
T021U=sum(sum(C * t(C) * Ec))/2;
T021C=sum(sum(C %*% C * Ec));
T111D=sum(sum(A %*% t(A) * Ec - M %*% M * Ec - C %*% t(C) * Ec))/2;
T111U=sum(sum(t(A) %*% A * Ec - M %*% M * Ec - t(C) %*% C * Ec))/2;
T030T=sum(sum(C %*% C * C));
T030C=tr(C %*% C %*% C)/3;
T201=sum(sum(M %*% M * Ec))/2;
T120D=sum(sum(t(C) %*% C * M))/2;
T120U=sum(sum(C %*% t(C) * M))/2;
T120C=sum(sum(C %*% C * M));
T210=sum(sum(M %*% M *(C + t(C))))/2;
T300=tr(M %*% M %*% M)/6;
}
proc.time() - ptm
q()
